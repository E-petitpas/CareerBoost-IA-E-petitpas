const { supabase } = require('../config/supabase');
const franceTravailService = require('./franceTravailService');
const skillsParsingService = require('./skillsParsingService');

class OfferAggregationService {
  constructor() {
    this.isRunning = false;
    this.lastSyncTime = null;
    this.syncIntervalHours = parseInt(process.env.FRANCE_TRAVAIL_SYNC_INTERVAL_HOURS) || 6;
    this.maxOffersPerSync = parseInt(process.env.FRANCE_TRAVAIL_MAX_OFFERS_PER_SYNC) || 500;
    this.enabled = process.env.FRANCE_TRAVAIL_SYNC_ENABLED === 'true';
  }

  /**
   * D√©marrer la synchronisation automatique des offres
   */
  startAutoSync() {
    if (!this.enabled) {
      console.log('Agr√©gation France Travail: Synchronisation d√©sactiv√©e');
      return;
    }

    console.log(`Agr√©gation France Travail: D√©marrage de la synchronisation automatique (toutes les ${this.syncIntervalHours}h)`);
    
    // Synchronisation imm√©diate
    this.syncOffers();
    
    // Programmer les synchronisations suivantes
    setInterval(() => {
      this.syncOffers();
    }, this.syncIntervalHours * 60 * 60 * 1000);
  }

  /**
   * Synchroniser les offres depuis France Travail
   */
  async syncOffers() {
    if (this.isRunning) {
      console.log('Agr√©gation France Travail: Synchronisation d√©j√† en cours, ignor√©e');
      return;
    }

    this.isRunning = true;
    console.log('Agr√©gation France Travail: D√©but de la synchronisation');

    try {
      const startTime = Date.now();
      let totalProcessed = 0;
      let totalCreated = 0;
      let totalSkipped = 0;
      let totalErrors = 0;

      // Obtenir l'ID de l'entreprise France Travail
      const franceTravailCompanyId = await franceTravailService.getOrCreateFranceTravailCompany();

      // Rechercher les offres par domaines d'activit√©
      // Filtr√© pour E-Petitpas : uniquement informatique et formations num√©riques
      const domains = [
        'M18' // Informatique et t√©l√©communications
      ];

      for (const domain of domains) {
        try {
          console.log(`Agr√©gation France Travail: Traitement du domaine ${domain}`);
          
          const searchResult = await franceTravailService.searchOffers({
            domaine: domain,
            range: `0-${Math.floor(Math.min(this.maxOffersPerSync / domains.length, 149))}`,
            sort: '1', // Tri par date de cr√©ation
            // Inclure l'alternance pour E-Petitpas (formation)
            typeContrat: 'CDI,CDD,MIS,SAI' // SAI = Contrat d'apprentissage/alternance
            // Temporairement sans mots-cl√©s pour tester l'alternance
            // motsCles: 'd√©veloppeur,programmeur,informatique,web,logiciel,formation,num√©rique'
          });

          if (searchResult.resultats && searchResult.resultats.length > 0) {
            const results = await this.processOffers(searchResult.resultats, franceTravailCompanyId);
            totalProcessed += results.processed;
            totalCreated += results.created;
            totalSkipped += results.skipped;
            totalErrors += results.errors;
          }

          // Pause entre les domaines pour √©viter le rate limiting
          await this.sleep(1000);
        } catch (error) {
          console.error(`Erreur lors du traitement du domaine ${domain}:`, error);
          totalErrors++;
        }
      }

      const duration = Date.now() - startTime;
      this.lastSyncTime = new Date();

      console.log(`Agr√©gation France Travail: Synchronisation termin√©e en ${duration}ms`);
      console.log(`- Offres trait√©es: ${totalProcessed}`);
      console.log(`- Offres cr√©√©es: ${totalCreated}`);
      console.log(`- Offres ignor√©es (doublons): ${totalSkipped}`);
      console.log(`- Erreurs: ${totalErrors}`);

      // Enregistrer les statistiques de synchronisation
      await this.saveSyncStats({
        processed: totalProcessed,
        created: totalCreated,
        skipped: totalSkipped,
        errors: totalErrors,
        duration,
        source: 'FRANCE_TRAVAIL'
      });

    } catch (error) {
      console.error('Erreur lors de la synchronisation France Travail:', error);
    } finally {
      this.isRunning = false;
    }
  }

  /**
   * Traiter une liste d'offres France Travail
   */
  async processOffers(offers, companyId) {
    let processed = 0;
    let created = 0;
    let skipped = 0;
    let errors = 0;

    for (const franceTravailOffer of offers) {
      try {
        processed++;
        
        // Normaliser l'offre
        const normalizedOffer = franceTravailService.normalizeOffer(franceTravailOffer);
        normalizedOffer.company_id = companyId;

        // V√©rifier si l'offre existe d√©j√† (d√©duplication)
        const { data: existingOffer } = await supabase
          .from('job_offers')
          .select('id')
          .eq('dedup_hash', normalizedOffer.dedup_hash)
          .maybeSingle(); // Utiliser maybeSingle() au lieu de single() pour √©viter les erreurs si pas trouv√©

        if (existingOffer) {
          skipped++;
          console.log(`Offre ignor√©e (doublon): ${normalizedOffer.title} (hash: ${normalizedOffer.dedup_hash})`);
          continue;
        }

        // Cr√©er l'offre avec gestion des erreurs de contrainte unique
        const { data: createdOffer, error: offerError } = await supabase
          .from('job_offers')
          .insert(normalizedOffer)
          .select('id')
          .single();

        if (offerError) {
          // Gestion sp√©cifique des erreurs de contrainte unique (doublons)
          if (offerError.code === '23505' && offerError.message.includes('unique_dedup_hash')) {
            console.log(`Offre ignor√©e (doublon d√©tect√© lors de l'insertion): ${normalizedOffer.title} (hash: ${normalizedOffer.dedup_hash})`);
            skipped++;
            continue;
          }

          console.error('Erreur cr√©ation offre:', offerError);
          console.error('Donn√©es de l\'offre:', {
            title: normalizedOffer.title,
            dedup_hash: normalizedOffer.dedup_hash,
            company_id: normalizedOffer.company_id
          });
          errors++;
          continue;
        }

        // Extraire et associer les comp√©tences
        await this.extractAndAssociateSkills(franceTravailOffer, createdOffer.id);

        created++;
        console.log(`Offre cr√©√©e: ${normalizedOffer.title} (ID: ${createdOffer.id})`);

      } catch (error) {
        console.error('Erreur lors du traitement de l\'offre:', error);
        errors++;
      }
    }

    return { processed, created, skipped, errors };
  }

  /**
   * Extraire et associer les comp√©tences depuis une offre France Travail
   */
  async extractAndAssociateSkills(franceTravailOffer, offerId) {
    try {
      console.log(`üîç Parsing comp√©tences pour offre: ${franceTravailOffer.intitule}`);

      // Utiliser notre service de parsing robuste
      const description = franceTravailOffer.description || '';
      const title = franceTravailOffer.intitule || '';

      // Parser les comp√©tences avec notre service am√©lior√©
      const parsedSkills = skillsParsingService.parseSkillsFromDescription(description, title);
      console.log(`üìã ${parsedSkills.length} comp√©tences pars√©es automatiquement`);

      // Ajouter les comp√©tences sp√©cifiques France Travail si disponibles
      const franceTravailSkills = [];
      if (franceTravailOffer.competences) {
        for (const competence of franceTravailOffer.competences) {
          if (competence.libelle) {
            franceTravailSkills.push({
              display_name: competence.libelle,
              slug: competence.libelle.toLowerCase().replace(/[^a-z0-9]/g, '-'),
              is_required: competence.exigence === 'E', // E = Exig√©, S = Souhait√©
              weight: competence.exigence === 'E' ? 3 : 1,
              category: 'France Travail'
            });
          }
        }
        console.log(`üìã ${franceTravailSkills.length} comp√©tences France Travail ajout√©es`);
      }

      // Combiner les comp√©tences pars√©es et France Travail
      const allSkills = [...parsedSkills, ...franceTravailSkills];
      
      // Utiliser notre service pour associer les comp√©tences √† la base de donn√©es
      const matchedSkills = await skillsParsingService.matchSkillsToDatabase(allSkills, supabase);
      console.log(`‚úÖ ${matchedSkills.length} comp√©tences match√©es en base de donn√©es`);

      // Mettre √† jour l'offre avec les comp√©tences
      if (matchedSkills.length > 0) {
        await skillsParsingService.updateOfferSkills(offerId, matchedSkills, supabase);
        console.log(`üéâ Offre ${offerId} mise √† jour avec ${matchedSkills.length} comp√©tences`);

        // Log des comp√©tences ajout√©es pour debug
        const requiredSkills = matchedSkills.filter(s => s.is_required);
        const optionalSkills = matchedSkills.filter(s => !s.is_required);
        console.log(`   - ${requiredSkills.length} comp√©tences obligatoires`);
        console.log(`   - ${optionalSkills.length} comp√©tences optionnelles`);
      } else {
        console.log(`‚ö†Ô∏è Aucune comp√©tence match√©e pour l'offre ${offerId}, tentative avec IA...`);

        // Fallback avec IA
        try {
          const aiSkills = await skillsParsingService.parseSkillsWithAI(description, title, supabase);

          if (aiSkills.length > 0) {
            // Associer les comp√©tences IA √† la base de donn√©es
            const aiMatchedSkills = await skillsParsingService.matchSkillsToDatabase(aiSkills, supabase);

            if (aiMatchedSkills.length > 0) {
              await skillsParsingService.updateOfferSkills(offerId, aiMatchedSkills, supabase);
              console.log(`ü§ñ Offre ${offerId} mise √† jour avec ${aiMatchedSkills.length} comp√©tences via IA`);
            } else {
              console.log(`‚ö†Ô∏è Comp√©tences IA non match√©es en base pour l'offre ${offerId}`);
            }
          } else {
            console.log(`‚ö†Ô∏è IA n'a trouv√© aucune comp√©tence pour l'offre ${offerId}`);
          }
        } catch (aiError) {
          console.error('‚ùå Erreur fallback IA:', aiError);
        }
      }
    } catch (error) {
      console.error('Erreur lors de l\'extraction des comp√©tences:', error);
    }
  }

  /**
   * Enregistrer les statistiques de synchronisation
   */
  async saveSyncStats(stats) {
    try {
      await supabase
        .from('sync_stats')
        .insert({
          ...stats,
          sync_date: new Date().toISOString()
        });
    } catch (error) {
      console.error('Erreur lors de l\'enregistrement des statistiques:', error);
    }
  }

  /**
   * Obtenir les statistiques de synchronisation
   */
  async getSyncStats(limit = 10) {
    try {
      const { data, error } = await supabase
        .from('sync_stats')
        .select('*')
        .order('sync_date', { ascending: false })
        .limit(limit);

      if (error) throw error;
      return data;
    } catch (error) {
      console.error('Erreur lors de la r√©cup√©ration des statistiques:', error);
      return [];
    }
  }

  /**
   * Synchronisation manuelle (pour l'admin)
   */
  async manualSync() {
    if (this.isRunning) {
      throw new Error('Une synchronisation est d√©j√† en cours');
    }

    console.log('Agr√©gation France Travail: Synchronisation manuelle d√©marr√©e');
    await this.syncOffers();
    return {
      success: true,
      message: 'Synchronisation termin√©e',
      lastSyncTime: this.lastSyncTime
    };
  }

  /**
   * Obtenir le statut de la synchronisation
   */
  getStatus() {
    return {
      enabled: this.enabled,
      isRunning: this.isRunning,
      lastSyncTime: this.lastSyncTime,
      syncIntervalHours: this.syncIntervalHours,
      maxOffersPerSync: this.maxOffersPerSync
    };
  }

  /**
   * Synchronisation manuelle (pour les tests)
   */
  async manualSync() {
    return await this.syncOffers();
  }

  /**
   * Utilitaire pour faire une pause
   */
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

module.exports = new OfferAggregationService();
